<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[The Weekend Blog]]></title>
  <link href="http://zhoumo199163.github.io/atom.xml" rel="self"/>
  <link href="http://zhoumo199163.github.io/"/>
  <updated>2021-05-30T21:11:01+08:00</updated>
  <id>http://zhoumo199163.github.io/</id>
  <author>
    <name><![CDATA[Weekend]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[App启动速度]]></title>
    <link href="http://zhoumo199163.github.io/blog/2021/05/29/appqi-dong-su-du/"/>
    <updated>2021-05-29T19:13:34+08:00</updated>
    <id>http://zhoumo199163.github.io/blog/2021/05/29/appqi-dong-su-du</id>
    <content type="html"><![CDATA[<p>一般情况下，App 的启动分为冷启动和热启动。</p>

<ul>
<li>冷启动是指， App 点击启动前，它的进程不在系统里，需要系统新创建一个进程分配给它启动的情况。这是一次完整的启动过程。</li>
<li>热启动是指 ，App 在冷启动后用户将 App 退后台，在 App 的进程还在系统里的情况下，用户重新启动进入 App 的过程，这个过程做的事情非常少。</li>
</ul>


<p>App 的启动时间，指的是从用户点击 App 开始，到用户看到第一个界面之间的时间。</p>

<p>App 的启动主要包括三个阶段：</p>

<ul>
<li>main() 函数执行前；</li>
<li>main() 函数执行后；</li>
<li>首屏渲染完成后。</li>
</ul>


<h4>main() 函数执行前</h4>

<p>在 main() 函数执行前，系统主要会做下面几件事情：</p>

<ul>
<li>加载可执行文件（App 的.o 文件的集合）；</li>
<li>加载动态链接库，进行 rebase 指针调整和 bind 符号绑定；</li>
<li>Objc 运行时的初始处理，包括 Objc 相关类的注册、category 注册、selector 唯一性检查等；</li>
<li>初始化，包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量。</li>
</ul>


<p>这个阶段对于启动速度优化来说，可以做的事情包括：</p>

<ul>
<li>减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司建议最多使用<strong>6</strong>个非系统动态库。</li>
<li><p>动态库是指可以共享的代码文件、资源文件、头文件等的打包集合体。在Xcode->Targets->General->Link Binary With Libraries可以检查自己的库</p></li>
<li><p>减少加载启动后不会去使用的类或者方法。</p></li>
<li>+load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。因为，在一个 +load() 方法里，进行运行时方法替换操作会带来 4 毫秒的消耗。不要小看这 4 毫秒，积少成多，执行 +load() 方法对启动速度的影响会越来越大。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>执行顺序：
</span><span class='line'> load -&gt; attribute((constructor)) -&gt; main -&gt; initialize
</span><span class='line'> 
</span><span class='line'>  + (void)initialize{
</span><span class='line'>    // 在类被第一次使用的时候调用
</span><span class='line'>  }
</span><span class='line'>  + (void)load{
</span><span class='line'>    // 在类被运行时加载时调用
</span><span class='line'>  }
</span><span class='line'>  __attribute((constructor)) void beforeMain(){
</span><span class='line'>  //是GCC的扩展语法（黑魔法），由它修饰过的函数，会在main函数之前调用
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>控制 C++ 全局变量的数量。</li>
</ul>


<h4>查看main()函数执行前的耗时：</h4>

<p>在Product->Scheme->Edit Scheme->Run->Arguments->Environment Variables->DYLD_PRINT_STATISTICS设置为YES，就可以在控制台中查看main函数执行前总共花费的多长时间。</p>

<hr />

<h4>main() 函数执行后</h4>

<p>main() 函数执行后的阶段，指的是从 main() 函数执行开始，到 appDelegate 的 didFinishLaunchingWithOptions 方法里首屏渲染相关方法执行完成。</p>

<p>优化方向：从功能上梳理出哪些是首屏渲染必要的初始化功能，哪些是 App 启动必要的初始化功能，而哪些是只需要在对应功能开始使用时才需要初始化的。梳理完之后，将这些初始化功能分别放到合适的阶段进行。</p>

<p><img src="https://s4.aconvert.com/convert/p3r68-cdx67/akuxa-q2t70.png" alt="alt text" /></p>

<hr />

<h4>首屏渲染完成后</h4>

<p>首屏渲染后的这个阶段，指的是didFinishLaunchWithOptions方法作用域内执行首屏渲染之后的所有方法执行完成，即从 设置了self.window.rootViewController开始 到 didFinishLaunchWithOptions方法作用域结束。</p>

<p>这个阶段用户已经能够看到 App 的首页信息了，所以优化的优先级排在最后。但是，那些会卡住主线程的方法还是需要最优先处理的，不然还是会影响到用户后面的交互操作。</p>

<hr />

<h2>功能级别的启动优化</h2>

<p>功能级别的启动优化，就是要从 main() 函数执行后这个阶段下手。</p>

<p>main() 函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做。</p>

<h2>方法级别的启动优化</h2>

<p>首先优化前需要先精准监控到都哪些方法需要优化，就是哪些方法更耗时
对 App 启动速度的监控，主要有两种手段。</p>

<ul>
<li>第一种方法是，定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时。Xcode 工具套件里自带的 Time Profiler ，采用的就是这种方式。</li>
<li>第二种方法是，对 objc_msgSend 方法进行 hook 来掌握所有方法的执行耗时。</li>
</ul>


<h3>第一种方法</h3>

<h4>Time Profiler</h4>

<p>Time Profiler每隔1ms会对线程的调用栈采样，然后用统计学的方式去做出分析。<br/>
Time Profiler用来分析代码的执行时间，主要用来分析CPU使用情况。
注意：要在release模式下分析。</p>

<p>缺点：</p>

<ul>
<li>定时间隔设置得长了，会漏掉一些方法，从而导致检查出来的耗时不精确；</li>
<li>而定时间隔设置得短了，抓取堆栈这个方法本身调用过多也会影响整体耗时，导致结果不准确。</li>
</ul>


<p>这个定时间隔如果小于所有方法执行的时间（比如 0.002 秒），那么基本就能监控到所有方法。但这样做的话，整体的耗时时间就不够准确。一般将这个定时间隔设置为 0.01 秒。这样设置，对整体耗时的影响小，不过很多方法耗时就不精确了。但因为整体耗时的数据更加重要些，单个方法耗时精度不高也是可以接受的，所以这个设置也是没问题的。</p>

<h4>总结来说，定时抓取主线程调用栈的方式虽然精准度不够高，但也是够用的。</h4>

<h4>实现类似Time Profiler的检测工具</h4>

<p>要获取线程的调用栈，github上有一个开源轻量级工具<a href="https://github.com/bestswifter/bsbacktracelogger">BSBacktraceLogger</a></p>

<h3>第二种方法实现</h3>

<p>主要是搬戴铭大佬的成果：<br/>
objc_msgSend 本身是用汇编语言写的，这样做的原因主要有两个：</p>

<ul>
<li>一个原因是，objc_msgSend 的调用频次最高，在它上面进行的性能优化能够提升整个 App 生命周期的性能。而汇编语言在性能优化上属于原子级优化，能够把优化做到极致。所以，这种投入产出比无疑是最大的。</li>
<li>另一个原因是，其他语言难以实现未知参数跳转到任意函数指针的功能。</li>
</ul>


<p>objc_msgSend 方法执行的逻辑是：先获取对象对应类的信息，再获取方法的缓存，根据方法的 selector 查找函数指针，经过异常错误处理后，最后跳到对应函数的实现。</p>

<h4>怎么hook objc_msgSend 方法？</h4>

<p>Facebook 开源了一个库，可以在 iOS 上运行的 Mach-O 二进制文件中动态地重新绑定符号，这个库叫 <a href="https://github.com/facebook/fishhook">fishhook</a>。</p>

<p><strong>fishhook 实现的大致思路是，通过重新绑定符号，可以实现对 c 方法的 hook。dyld 是通过更新 Mach-O 二进制的 __DATA segment 特定的部分中的指针来绑定 lazy 和 non-lazy 符号，通过确认传递给 rebind_symbol 里每个符号名称更新的位置，就可以找出对应替换来重新绑定这些符号。</strong></p>

<p>有了fishhook后还需要实现两个方法 pushCallRecord 和 popCallRecord，来分别记录 objc_msgSend 方法调用前后的时间，然后相减就能够得到方法的执行耗时。</p>

<p>具体实现参考戴铭老师的<a href="https://github.com/ming1016/GCDFetchFeed">github</a>中的SMCallTrace</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[预编译指令]]></title>
    <link href="http://zhoumo199163.github.io/blog/2021/05/22/yu-bian-yi-zhi-ling/"/>
    <updated>2021-05-22T17:09:41+08:00</updated>
    <id>http://zhoumo199163.github.io/blog/2021/05/22/yu-bian-yi-zhi-ling</id>
    <content type="html"><![CDATA[<h3>预编译指令</h3>

<p>以#开头的都是预编译指令，就是在正式编译之前，编译器做一些预处理的工作</p>

<table>
<thead>
<tr>
<th>  预编译指令   </th>
<th> 含义  </th>
</tr>
</thead>
<tbody>
<tr>
<td> #define   </td>
<td> 定义一个预处理宏 </td>
</tr>
<tr>
<td> #undef  </td>
<td>  取消宏的定义 </td>
</tr>
<tr>
<td> #if   </td>
<td> 编译预处理中的条件命令，相当于if语句 </td>
</tr>
<tr>
<td> #ifdef   </td>
<td> 判断某个宏是否被定义，若已定义，执行随后的语句 </td>
</tr>
<tr>
<td> #ifndef  </td>
<td> 与#ifdef相反，判断某个宏是否未被定义 </td>
</tr>
<tr>
<td> #elif   </td>
<td> 若#if, #ifdef, #ifndef或前面的#elif条件不满足，则执行#elif之后的语句，相当于else-if </td>
</tr>
<tr>
<td> #else  </td>
<td> 与#if, #ifdef, #ifndef对应, 若这些条件不满足，则执行#else之后的语句，相当于else </td>
</tr>
<tr>
<td> #endif   </td>
<td>  #if, #ifdef, #ifndef这些条件命令的结束标志.</td>
</tr>
<tr>
<td> defined   </td>
<td> 与#if, #elif配合使用，判断某个宏是否被定义 </td>
</tr>
</tbody>
</table>


<p>代码举例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 宏定义
</span><span class='line'>#define ISOK
</span><span class='line'>#define a 4
</span><span class='line'>#define b 5
</span><span class='line'>//取消宏定义
</span><span class='line'>//#undef ISOK
</span><span class='line'>
</span><span class='line'>// #if后面必须跟一个判断条件，如果需要判断是否有某个宏定义需要使用defined
</span><span class='line'>#if defined(ISOK)  //if
</span><span class='line'>    NSLog(@"#if==true");
</span><span class='line'>#elif (a==b)  // else if
</span><span class='line'>    NSLog(@"#elif==true");
</span><span class='line'>#else // else 
</span><span class='line'>    NSLog(@"#else==true");
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>    
</span><span class='line'>#ifdef ISOK 
</span><span class='line'>    NSLog(@"#ifdef:ISOK已有宏定义");
</span><span class='line'>#else 
</span><span class='line'>    NSLog(@"#ifdef:ISOK没有宏定义");
</span><span class='line'>#endif
</span><span class='line'>  
</span><span class='line'>#ifndef ISOK
</span><span class='line'>    NSLog(@"#ifndef:ISOK没有宏定义");
</span><span class='line'>#else
</span><span class='line'>    NSLog(@"#ifndef:ISOK已有宏定义");
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>一般在iOS中用到预编译指令的地方：</p>

<h4>1.调试代码：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#ifdef DEBUG
</span><span class='line'>// 调试代码 ，注意DEBUG宏是系统定义好的
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<h4>2.统一定义设备相关信息</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define NavigationBar_HEIGHT 44
</span><span class='line'>
</span><span class='line'>#define SCREEN_WIDTH ([UIScreen mainScreen].bounds.size.width)
</span><span class='line'>#define SCREEN_HEIGHT ([UIScreen mainScreen].bounds.size.height)
</span><span class='line'>
</span><span class='line'>#define IOS_VERSION ［[UIDevice currentDevice] systemVersion] floatValue]
</span><span class='line'>
</span><span class='line'>#define CurrentSystemVersion ［UIDevice currentDevice] systemVersion]
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h4>3.统一定义某个全局方法</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *    @brief  正确获取主线程
</span><span class='line'> */
</span><span class='line'>#ifndef dispatch_main_async_safe
</span><span class='line'>    #define dispatch_main_async_safe(block)\
</span><span class='line'>        if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) {\
</span><span class='line'>            (block());\
</span><span class='line'>        } else {\
</span><span class='line'>            dispatch_async(dispatch_get_main_queue(), block);\
</span><span class='line'>        }
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> *    @brief  在Debug模式显示日志，Release模式关闭日志，普通输出
</span><span class='line'> */
</span><span class='line'>#ifdef DEBUG
</span><span class='line'>#define Log( s, ... ) printf( "&lt;%s:(%d)&gt; %s %s\n\n", [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] cStringUsingEncoding:NSUTF8StringEncoding], __LINE__,__func__, [[NSString stringWithFormat:(s), ##__VA_ARGS__] cStringUsingEncoding:NSUTF8StringEncoding])
</span><span class='line'>#else
</span><span class='line'>#define Log( s, ... )
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> *    @brief  防止block循环引用
</span><span class='line'> */
</span><span class='line'>#ifndef weakify
</span><span class='line'>    #if TARGET_IPHONE_DEBUG
</span><span class='line'>        #if __has_feature(objc_arc)
</span><span class='line'>            #define weakify(object) @autoreleasepool{} __weak __typeof__(object) weak##_##object = object;
</span><span class='line'>        #else
</span><span class='line'>            #define weakify(object) @autoreleasepool{} __block __typeof__(object) block##_##object = object;
</span><span class='line'>        #endif
</span><span class='line'>    #else
</span><span class='line'>        #if __has_feature(objc_arc)
</span><span class='line'>            #define weakify(object) @try{} @finally{} {} __weak __typeof__(object) weak##_##object = object;
</span><span class='line'>        #else
</span><span class='line'>            #define weakify(object) @try{} @finally{} {} __block __typeof__(object) block##_##object = object;
</span><span class='line'>        #endif
</span><span class='line'>    #endif
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>#ifndef strongify
</span><span class='line'>    #if TARGET_IPHONE_DEBUG
</span><span class='line'>        #if __has_feature(objc_arc)
</span><span class='line'>            #define strongify(object) @autoreleasepool{} __typeof__(object) object = weak##_##object;
</span><span class='line'>        #else
</span><span class='line'>            #define strongify(object) @autoreleasepool{} __typeof__(object) object = block##_##object;
</span><span class='line'>        #endif
</span><span class='line'>    #else
</span><span class='line'>        #if __has_feature(objc_arc)
</span><span class='line'>            #define strongify(object) @try{} @finally{} __typeof__(object) object = weak##_##object;
</span><span class='line'>        #else
</span><span class='line'>            #define strongify(object) @try{} @finally{} __typeof__(object) object = block##_##object;
</span><span class='line'>        #endif
</span><span class='line'>    #endif
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> *    @brief rgb颜色转换（16进制-&gt;10进制）
</span><span class='line'> */
</span><span class='line'> #define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue & 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue & 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue & 0xFF))/255.0 alpha:1.0]
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> *    @brief 通知
</span><span class='line'> */
</span><span class='line'>#define POST_NOTIFY(__NAME, __OBJ, __INFO) [[NSNotificationCenter defaultCenter] postNotificationName:__NAME object:__OBJ userInfo:__INFO];
</span><span class='line'>
</span><span class='line'>#define LISTEN_NOTIFY(__NAME, __OBSERVER, __SELECTOR) [[NSNotificationCenter defaultCenter] addObserver:__OBSERVER selector:__SELECTOR name:__NAME object:nil];
</span><span class='line'>
</span><span class='line'>#define REMOVE_NOTIFY(__OBSERVER) [[NSNotificationCenter defaultCenter] removeObserver:__OBSERVER];</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React学习笔记]]></title>
    <link href="http://zhoumo199163.github.io/blog/2021/05/15/reactxue-xi-bi-ji/"/>
    <updated>2021-05-15T20:16:06+08:00</updated>
    <id>http://zhoumo199163.github.io/blog/2021/05/15/reactxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<h3>入门教程</h3>

<ul>
<li><p>状态提升：当你遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，需要把子组件的 state 数据提升至其共同的父组件当中保存。之后父组件可以通过 props 将状态数据传递到子组件当中。这样应用当中所有组件的状态数据就能够更方便地同步共享了。</p></li>
<li><p>为了提高可读性，我们把返回的 React 元素拆分成了多行，同时在最外层加了小括号，这样 JavaScript 解析的时候就不会在 return 的后面自动插入一个分号从而破坏代码结构了。</p></li>
<li><p>在 React 中，有一个命名规范，通常会将代表事件的监听 prop 命名为 on[Event]，将处理事件的监听方法命名为 handle[Event] 这样的格式。</p></li>
<li><p>concat() 方法可能与你比较熟悉的 push() 方法不太一样，它并不会改变原数组，所以我们推荐使用 concat()</p></li>
</ul>


<h3>KEY</h3>

<ul>
<li><p>每当一个列表重新渲染时，React 会根据每一项列表元素的 key 来检索上一次渲染时与每个 key 所匹配的列表项。如果 React 发现当前的列表有一个之前不存在的 key，那么就会创建出一个新的组件。如果 React 发现和之前对比少了一个 key，那么就会销毁之前对应的组件。如果一个组件的 key 发生了变化，这个组件会被销毁，然后使用新的 state 重新创建一份。</p></li>
<li><p>key 是 React 中一个特殊的保留属性（还有一个是 ref，拥有更高级的特性）。当 React 元素被创建出来的时候，React 会提取出 key 属性，然后把 key 直接存储在返回的元素上。虽然 key 看起来好像是 props 中的一个，但是你不能通过 this.props.key 来获取 key。React 会通过 key 来自动判断哪些组件需要更新。组件是不能访问到它的 key 的。</p></li>
<li><p>我们强烈推荐，每次只要你构建动态列表的时候，都要指定一个合适的 key。如果你没有找到一个合适的 key，那么你就需要考虑重新整理你的数据结构了，这样才能有合适的 key。</p></li>
</ul>


<h3>函数组件</h3>

<ul>
<li>如果你想写的组件只包含一个 render 方法，并且不包含 state，那么使用函数组件就会更简单。我们不需要定义一个继承于 React.Component 的类，我们可以定义一个函数，这个函数接收 props 作为参数，然后返回需要渲染的元素。函数组件写起来并不像 class 组件那么繁琐，很多组件都可以使用函数组件来写。</li>
</ul>


<p>定义组件最简单的方式就是编写 JavaScript 函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> function Welcome(props) {
</span><span class='line'>  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
</span><span class='line'>}
</span><span class='line'>￼ES6：
</span><span class='line'>class Welcome extends React.Component {
</span><span class='line'>  render() {
</span><span class='line'>      return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>注意： 组件名称必须以大写字母开头。</span></code></pre></td></tr></table></div></figure>


<h3>Props的只读性</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> function sum(a, b) {
</span><span class='line'>  return a + b;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>这样的函数被称为“纯函数”，因为该函数不会尝试更改入参，且多次调用下相同的入参始终返回相同的结果。
相反，下面这个函数则不是纯函数，因为它更改了自己的入参：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function withdraw(account, amount) {
</span><span class='line'>  account.total -= amount;
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>React 非常灵活，但它也有一个严格的规则：
<strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</strong></li>
</ul>


<h3>正确地使用 State</h3>

<ul>
<li>不要直接修改 State，要使用setState()</li>
<li>State 的更新可能是异步的</li>
</ul>


<p>出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。
因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> // Wrong
</span><span class='line'>this.setState({
</span><span class='line'>  counter: this.state.counter + this.props.increment,
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> // Correct
</span><span class='line'>this.setState((state, props) =&gt; ({
</span><span class='line'>  counter: state.counter + props.increment
</span><span class='line'>}));
</span><span class='line'>this.setState(state =&gt; ({
</span><span class='line'>  isToggleOn: !state.isToggleOn
</span><span class='line'>}));</span></code></pre></td></tr></table></div></figure>


<ul>
<li>State 的更新会被合并</li>
</ul>


<p> 当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。</p>

<ul>
<li>这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</li>
</ul>


<h3>事件处理</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> class LoggingButton extends React.Component {
</span><span class='line'>  handleClick() {
</span><span class='line'>    console.log('this is:', this);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  render() {
</span><span class='line'>    // 此语法确保 `handleClick` 内的 `this` 已被绑定。
</span><span class='line'>    return (
</span><span class='line'>      &lt;button onClick={() =&gt; this.handleClick()}&gt;
</span><span class='line'>        Click me
</span><span class='line'>      &lt;/button&gt;
</span><span class='line'>    );
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>此语法问题在于每次渲染 LoggingButton 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> class LoggingButton extends React.Component {
</span><span class='line'>  // 此语法确保 `handleClick` 内的 `this` 已被绑定。
</span><span class='line'>  // 注意: 这是 *实验性* 语法。
</span><span class='line'>  handleClick = () =&gt; {
</span><span class='line'>  //  class fields 
</span><span class='line'>    console.log('this is:', this);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  render() {
</span><span class='line'>    return (
</span><span class='line'>      &lt;button onClick={this.handleClick}&gt;
</span><span class='line'>        Click me
</span><span class='line'>      &lt;/button&gt;
</span><span class='line'>    );
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> &lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;
</span><span class='line'>&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在这两种情况下，React 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。</li>
</ul>


<h3>列表 &amp; Key</h3>

<ul>
<li>一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串</li>
<li>一个好的经验法则是：<strong>在 map() 方法中的元素需要设置 key 属性。</strong></li>
</ul>


<h3>React.lazy</h3>

<ul>
<li>React.lazy 函数能让你像渲染常规组件一样处理动态引入（的组件）。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 使用之前：
</span><span class='line'>import OtherComponent from './OtherComponent';
</span><span class='line'>使用之后：
</span><span class='line'>const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));</span></code></pre></td></tr></table></div></figure>


<ul>
<li>React.lazy 目前只支持默认导出（default exports）。如果你想被引入的模块使用命名导出（named exports），你可以创建一个中间模块，来重新导出为默认模块。这能保证 tree shaking 不会出错，并且不必引入不需要的组件。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> // ManyComponents.js
</span><span class='line'>export const MyComponent = /* ... */;
</span><span class='line'>export const MyUnusedComponent = /* ... */;
</span><span class='line'>// MyComponent.js
</span><span class='line'>export { MyComponent as default } from "./ManyComponents.js";
</span><span class='line'>// MyApp.js
</span><span class='line'>import React, { lazy } from 'react';
</span><span class='line'>const MyComponent = lazy(() =&gt; import("./MyComponent.js"));</span></code></pre></td></tr></table></div></figure>


<h3>Context</h3>

<ul>
<li>Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。</li>
<li>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> const MyContext = React.createContext(defaultValue);</span></code></pre></td></tr></table></div></figure>


<ul>
<li>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。
只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。这有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;MyContext.Provider value={/* 某个值 */}&gt;
</span><span class='line'>￼MyClass.contextType = MyContext;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> class MyClass extends React.Component {
</span><span class='line'>static contextType = MyContext;
</span><span class='line'>render() {
</span><span class='line'>let value = this.context;
</span><span class='line'>/* 基于这个值进行渲染工作 */
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>￼&lt;MyContext.Consumer&gt;
</span><span class='line'>￼{value =&gt; /* 基于 context 值进行渲染*/}
</span><span class='line'>￼&lt;/MyContext.Consumer&gt;</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> const MyContext = React.createContext(/* some value */);
</span><span class='line'>MyContext.displayName = 'MyDisplayName';
</span><span class='line'>&lt;MyContext.Provider&gt; // "MyDisplayName.Provider" 在 DevTools 中
</span><span class='line'>&lt;MyContext.Consumer&gt; // "MyDisplayName.Consumer" 在 DevTools 中</span></code></pre></td></tr></table></div></figure>


<h3>错误边界</h3>

<ul>
<li>错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI</li>
<li>错误边界无法捕获以下场景中产生的错误：</li>
<li>事件处理</li>
<li>异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数</li>
<li>服务端渲染</li>
<li><p>它自身抛出来的错误（并非它的子组件）</p></li>
<li><p>如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   static getDerivedStateFromError(error) {
</span><span class='line'>    // 更新 state 使下一次渲染能够显示降级后的 UI
</span><span class='line'>    return { hasError: true };
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  componentDidCatch(error, errorInfo) {
</span><span class='line'>    // 你同样可以将错误日志上报给服务器
</span><span class='line'>    logErrorToMyService(error, errorInfo);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h3>Refs 转发</h3>

<ul>
<li>Ref 转发是一个可选特性，其允许某些组件接收 ref，并将其向下传递（换句话说，“转发”它）给子组件。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//3.React 传递 ref 给 forwardRef 内函数 (props, ref) =&gt; ...，作为其第二个参数。
</span><span class='line'>const FancyButton = React.forwardRef((props, ref) =&gt; (
</span><span class='line'>//4.我们向下转发该 ref 参数到 &lt;button ref={ref}&gt;，将其指定为 JSX 属性。
</span><span class='line'>//5.当 ref 挂载完成，ref.current 将指向 &lt;button&gt; DOM 节点。
</span><span class='line'>  &lt;button ref={ref} className="FancyButton"&gt;
</span><span class='line'>    {props.children}
</span><span class='line'>  &lt;/button&gt;
</span><span class='line'>));
</span><span class='line'>
</span><span class='line'>// 1.我们通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。
</span><span class='line'>const ref = React.createRef();
</span><span class='line'>// 2.我们通过指定 ref 为 JSX 属性，将其向下传递给 &lt;FancyButton ref={ref}&gt;。
</span><span class='line'>&lt;FancyButton ref={ref}&gt;Click me!&lt;/FancyButton&gt;;</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>第二个参数 ref 只在使用 React.forwardRef 定义组件时存在。常规函数和 class 组件不接收 ref 参数，且 props 中也不存在 ref。</p></li>
<li><p>一个输出组件 props 到控制台的 HOC (高阶组件)示例:</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function logProps(WrappedComponent) {
</span><span class='line'>  class LogProps extends React.Component {
</span><span class='line'>    componentDidUpdate(prevProps) {
</span><span class='line'>      console.log('old props:', prevProps);
</span><span class='line'>      console.log('new props:', this.props);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    render() {
</span><span class='line'>      return &lt;WrappedComponent {...this.props} /&gt;;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return LogProps;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 使用
</span><span class='line'>class FancyButton extends React.Component {
</span><span class='line'>  focus() {
</span><span class='line'>    // ...
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // ...
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 我们导出 LogProps，而不是 FancyButton。
</span><span class='line'>// 虽然它也会渲染一个 FancyButton。
</span><span class='line'>export default logProps(FancyButton);</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>以上例子直接使用ref会挂载到logProps上，而不是FancyButton</p></li>
<li><p>改进示例：</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function logProps(Component) {
</span><span class='line'>  class LogProps extends React.Component {
</span><span class='line'>    componentDidUpdate(prevProps) {
</span><span class='line'>      console.log('old props:', prevProps);
</span><span class='line'>      console.log('new props:', this.props);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    render() {
</span><span class='line'>      const {forwardedRef, ...rest} = this.props;
</span><span class='line'>
</span><span class='line'>      // 将自定义的 prop 属性 “forwardedRef” 定义为 ref
</span><span class='line'>      return &lt;Component ref={forwardedRef} {...rest} /&gt;;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // 注意 React.forwardRef 回调的第二个参数 “ref”。
</span><span class='line'>  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”
</span><span class='line'>  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。
</span><span class='line'>  return React.forwardRef((props, ref) =&gt; {
</span><span class='line'>    return &lt;LogProps {...props} forwardedRef={ref} /&gt;;
</span><span class='line'>  });
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>Fragments</h3>

<ul>
<li>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>render() {
</span><span class='line'>  return (
</span><span class='line'>    &lt;React.Fragment&gt;
</span><span class='line'>      &lt;ChildA /&gt;
</span><span class='line'>      &lt;ChildB /&gt;
</span><span class='line'>      &lt;ChildC /&gt;
</span><span class='line'>    &lt;/React.Fragment&gt;
</span><span class='line'>  );
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>你可以使用一种新的，且更简短的语法来声明 Fragments。它看起来像空标签：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Columns extends React.Component {
</span><span class='line'>  render() {
</span><span class='line'>    return (
</span><span class='line'>      &lt;&gt;
</span><span class='line'>        &lt;td&gt;Hello&lt;/td&gt;
</span><span class='line'>        &lt;td&gt;World&lt;/td&gt;
</span><span class='line'>      &lt;/&gt;
</span><span class='line'>    );
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>key 是唯一可以传递给 Fragment 的属性。</strong></li>
</ul>


<h3>高阶组件HOC</h3>

<ul>
<li><p>高阶组件是参数为组件，返回值为新组件的函数</p></li>
<li><p>组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p></li>
<li><p>HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。</p></li>
</ul>


<h4>将不相关的 props 传递给被包裹的组件</h4>

<ul>
<li>HOC 为组件添加特性。自身不应该大幅改变约定。HOC 返回的组件与原组件应保持类似的接口。</li>
</ul>


<p>HOC 应该透传与自身无关的 props。大多数 HOC 都应该包含一个类似于下面的 render 方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>render() {
</span><span class='line'>  // 过滤掉非此 HOC 额外的 props，且不要进行透传
</span><span class='line'>  const { extraProp, ...passThroughProps } = this.props;
</span><span class='line'>
</span><span class='line'>  // 将 props 注入到被包装的组件中。
</span><span class='line'>  // 通常为 state 的值或者实例方法。
</span><span class='line'>  const injectedProp = someStateOrInstanceMethod;
</span><span class='line'>
</span><span class='line'>  // 将 props 传递给被包装组件
</span><span class='line'>  return (
</span><span class='line'>    &lt;WrappedComponent
</span><span class='line'>      injectedProp={injectedProp}
</span><span class='line'>      {...passThroughProps}
</span><span class='line'>    /&gt;
</span><span class='line'>  );
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>最大化可组合性</h4>

<h4>包装显示名称以便轻松调试</h4>

<ul>
<li>请选择一个显示名称，以表明它是 HOC 的产物。</li>
<li>最常见的方式是用 HOC 包住被包装组件的显示名称。比如高阶组件名为 withSubscription，并且被包装组件的显示名称为 CommentList，显示名称应该为 WithSubscription(CommentList)：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function withSubscription(WrappedComponent) {
</span><span class='line'>  class WithSubscription extends React.Component {/* ... */}
</span><span class='line'>  WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;
</span><span class='line'>  return WithSubscription;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>function getDisplayName(WrappedComponent) {
</span><span class='line'>  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>HOC注意事项</h4>

<ul>
<li>不要在 render 方法中使用 HOC</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>render() {
</span><span class='line'>  // 每次调用 render 函数都会创建一个新的 EnhancedComponent
</span><span class='line'>  // EnhancedComponent1 !== EnhancedComponent2
</span><span class='line'>  const EnhancedComponent = enhance(MyComponent);
</span><span class='line'>  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！
</span><span class='line'>  return &lt;EnhancedComponent /&gt;;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有子组件的状态丢失。
你可以在组件的生命周期方法或其构造函数中进行调用。</p>

<ul>
<li>务必复制静态方法
当你将 HOC 应用于组件时，原始组件将使用容器组件进行包装。这意味着新组件没有原始组件的任何静态方法。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 定义静态函数
</span><span class='line'>WrappedComponent.staticMethod = function() {/*...*/}
</span><span class='line'>// 现在使用 HOC
</span><span class='line'>const EnhancedComponent = enhance(WrappedComponent);
</span><span class='line'>
</span><span class='line'>// 增强组件没有 staticMethod
</span><span class='line'>typeof EnhancedComponent.staticMethod === 'undefined' // true</span></code></pre></td></tr></table></div></figure>


<p>为了解决这个问题，你可以在返回之前把这些方法拷贝到容器组件上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function enhance(WrappedComponent) {
</span><span class='line'>  class Enhance extends React.Component {/*...*/}
</span><span class='line'>  // 必须准确知道应该拷贝哪些方法 :(
</span><span class='line'>  Enhance.staticMethod = WrappedComponent.staticMethod;
</span><span class='line'>  return Enhance;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>另一个可行的方案是再额外导出这个静态方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 使用这种方式代替...
</span><span class='line'>MyComponent.someFunction = someFunction;
</span><span class='line'>export default MyComponent;
</span><span class='line'>
</span><span class='line'>// ...单独导出该方法...
</span><span class='line'>export { someFunction };
</span><span class='line'>
</span><span class='line'>// ...并在要使用的组件中，import 它们
</span><span class='line'>import MyComponent, { someFunction } from './MyComponent.js';
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Refs 不会被传递</li>
</ul>


<h3>JSX</h3>

<p>实际上，JSX 仅仅只是 React.createElement(component, props, &hellip;children) 函数的语法糖。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;MyButton color="blue" shadowSize={2}&gt;
</span><span class='line'>  Click Me
</span><span class='line'>&lt;/MyButton&gt;
</span><span class='line'>会编译为：
</span><span class='line'>React.createElement(
</span><span class='line'>  MyButton,
</span><span class='line'>  {color: 'blue', shadowSize: 2},
</span><span class='line'>  'Click Me'
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<h4>React 必须在作用域内</h4>

<p>由于 JSX 会编译为 React.createElement 调用形式，所以 React 库也必须包含在 JSX 代码作用域内。
在如下代码中，虽然 React 和 CustomButton 并没有被直接使用，但还是需要导入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import React from 'react';
</span><span class='line'>import CustomButton from './CustomButton';
</span><span class='line'>
</span><span class='line'>function WarningButton() {
</span><span class='line'>  // return React.createElement(CustomButton, {color: 'red'}, null);
</span><span class='line'>  return &lt;CustomButton color="red" /&gt;;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>在 JSX 类型中使用点语法</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import React from 'react';
</span><span class='line'>
</span><span class='line'>const MyComponents = {
</span><span class='line'>  DatePicker: function DatePicker(props) {
</span><span class='line'>    return &lt;div&gt;Imagine a {props.color} datepicker here.&lt;/div&gt;;
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>function BlueDatePicker() {
</span><span class='line'>  return &lt;MyComponents.DatePicker color="blue" /&gt;;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>用户定义的组件必须以大写字母开头</h4>

<p>以小写字母开头的元素代表一个 HTML 内置组件，比如 <code>&lt;div&gt;</code> 或者 <code>&lt;span&gt;</code>会生成相应的字符串 &lsquo;div&rsquo; 或者 &lsquo;span&rsquo; 传递给 React.createElement（作为参数）。大写字母开头的元素则对应着在 JavaScript 引入或自定义的组件，如 <Foo /> 会编译为 React.createElement(Foo)。</p>

<p><strong>我们建议使用大写字母开头命名自定义组件。如果你确实需要一个以小写字母开头的组件，则在 JSX 中使用它之前，必须将它赋值给一个大写字母开头的变量。</strong></p>

<h4>在运行时选择类型</h4>

<p>你不能将通用表达式作为 React 元素类型。如果你想通过通用表达式来（动态）决定元素类型，你需要首先将它赋值给大写字母开头的变量。这通常用于根据 prop 来渲染不同组件的情况下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import React from 'react';
</span><span class='line'>import { PhotoStory, VideoStory } from './stories';
</span><span class='line'>
</span><span class='line'>const components = {
</span><span class='line'>  photo: PhotoStory,
</span><span class='line'>  video: VideoStory
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>function Story(props) {
</span><span class='line'>  // 错误！JSX 类型不能是一个表达式。
</span><span class='line'>  return &lt;components[props.storyType] story={props.story} /&gt;;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>要解决这个问题, 需要首先将类型赋值给一个大写字母开头的变量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import React from 'react';
</span><span class='line'>import { PhotoStory, VideoStory } from './stories';
</span><span class='line'>
</span><span class='line'>const components = {
</span><span class='line'>  photo: PhotoStory,
</span><span class='line'>  video: VideoStory
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>function Story(props) {
</span><span class='line'>  // 正确！JSX 类型可以是大写字母开头的变量。
</span><span class='line'>  const SpecificStory = components[props.storyType];
</span><span class='line'>  return &lt;SpecificStory story={props.story} /&gt;;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>JSX 中的 Props</h3>

<h4>JavaScript 表达式作为 Props</h4>

<p>你可以把包裹在 {} 中的 JavaScript 表达式作为一个 prop 传递给 JSX 元素。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;MyComponent foo={1 + 2 + 3 + 4} /&gt;</span></code></pre></td></tr></table></div></figure>


<p>if 语句以及 for 循环不是 JavaScript 表达式，所以不能在 JSX 中直接使用。</p>

<h4>字符串字面量</h4>

<p>你可以将字符串字面量赋值给 prop.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;MyComponent message="hello world" /&gt;
</span><span class='line'>// 等价
</span><span class='line'>&lt;MyComponent message={'hello world'} /&gt;</span></code></pre></td></tr></table></div></figure>


<p>当你将字符串字面量赋值给 prop 时，它的值是未转义的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;MyComponent message="&lt;3" /&gt;
</span><span class='line'>// 等价
</span><span class='line'>&lt;MyComponent message={'&lt;3'} /&gt;</span></code></pre></td></tr></table></div></figure>


<h4>Props 默认值为 “True”</h4>

<p><strong>如果你没给 prop 赋值，它的默认值是 true。</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;MyTextBox autocomplete /&gt;
</span><span class='line'>// 等价
</span><span class='line'>&lt;MyTextBox autocomplete={true} /&gt;</span></code></pre></td></tr></table></div></figure>


<p><strong>通常，我们不建议不传递 value 给 prop，因为这可能与 ES6 对象简写混淆，{foo} 是 {foo: foo} 的简写，而不是 {foo: true}。</strong></p>

<h4>属性展开</h4>

<p>如果你已经有了一个 props 对象，你可以使用展开运算符 &hellip; 来在 JSX 中传递整个 props 对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function App1() {
</span><span class='line'>  return &lt;Greeting firstName="Ben" lastName="Hector" /&gt;;
</span><span class='line'>}
</span><span class='line'>// 等价
</span><span class='line'>function App2() {
</span><span class='line'>  const props = {firstName: 'Ben', lastName: 'Hector'};
</span><span class='line'>  return &lt;Greeting {...props} /&gt;;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你还可以选择只保留当前组件需要接收的 props，并使用展开运算符将其他 props 传递下去。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const Button = props =&gt; {
</span><span class='line'>  const { kind, ...other } = props;
</span><span class='line'>  const className = kind === "primary" ? "PrimaryButton" : "SecondaryButton";
</span><span class='line'>  return &lt;button className={className} {...other} /&gt;;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>const App = () =&gt; {
</span><span class='line'>  return (
</span><span class='line'>    &lt;div&gt;
</span><span class='line'>      &lt;Button kind="primary" onClick={() =&gt; console.log("clicked!")}&gt;
</span><span class='line'>        Hello World!
</span><span class='line'>      &lt;/Button&gt;
</span><span class='line'>    &lt;/div&gt;
</span><span class='line'>  );
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>在上述例子中，kind 的 prop 会被安全的保留，它将不会被传递给 DOM 中的 <code>&lt;button&gt;</code> 元素。 所有其他的 props 会通过 &hellip;other 对象传递，使得这个组件的应用可以非常灵活。你可以看到它传递了一个 onClick 和 children 属性。</p>

<p><strong>属性展开在某些情况下很有用，但是也很容易将不必要的 props 传递给不相关的组件，或者将无效的 HTML 属性传递给 DOM。我们建议谨慎的使用该语法。</strong></p>

<h3>JSX 中的子元素</h3>

<p>包含在开始和结束标签之间的 JSX 表达式内容将作为特定属性 props.children 传递给外层组件。</p>

<h4>字符串字面量</h4>

<p>你可以将字符串放在开始和结束标签之间，此时 props.children 就只是该字符串。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt;</span></code></pre></td></tr></table></div></figure>


<p>这是一个合法的 JSX，MyComponent 中的 props.children 是一个简单的未转义字符串 &ldquo;Hello world!"。</p>

<p>JSX 会移除行首尾的空格以及空行。与标签相邻的空行均会被删除，文本字符串之间的新行会被压缩为一个空格。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;div&gt;Hello World&lt;/div&gt;
</span><span class='line'>
</span><span class='line'>&lt;div&gt;
</span><span class='line'>  Hello World
</span><span class='line'>&lt;/div&gt;
</span><span class='line'>
</span><span class='line'>&lt;div&gt;
</span><span class='line'>  Hello
</span><span class='line'>  World
</span><span class='line'>&lt;/div&gt;
</span><span class='line'>
</span><span class='line'>&lt;div&gt;
</span><span class='line'>
</span><span class='line'>  Hello World
</span><span class='line'>&lt;/div&gt;</span></code></pre></td></tr></table></div></figure>


<h4>JSX 子元素</h4>

<p>子元素允许由多个 JSX 元素组成。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;MyContainer&gt;
</span><span class='line'>  &lt;MyFirstComponent /&gt;
</span><span class='line'>  &lt;MySecondComponent /&gt;
</span><span class='line'>&lt;/MyContainer&gt;</span></code></pre></td></tr></table></div></figure>


<p>React 组件也能够返回存储在数组中的一组元素：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>render() {
</span><span class='line'>  // 不需要用额外的元素包裹列表元素！
</span><span class='line'>  return [
</span><span class='line'>    // 不要忘记设置 key :)
</span><span class='line'>    &lt;li key="A"&gt;First item&lt;/li&gt;,
</span><span class='line'>    &lt;li key="B"&gt;Second item&lt;/li&gt;,
</span><span class='line'>    &lt;li key="C"&gt;Third item&lt;/li&gt;,
</span><span class='line'>  ];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>JavaScript 表达式作为子元素</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;MyComponent&gt;foo&lt;/MyComponent&gt;
</span><span class='line'>// 等价
</span><span class='line'>&lt;MyComponent&gt;{'foo'}&lt;/MyComponent&gt;</span></code></pre></td></tr></table></div></figure>


<h4>函数作为子元素</h4>

<p>通常，JSX 中的 JavaScript 表达式将会被计算为字符串、React 元素或者是列表。不过，props.children 和其他 prop 一样，它可以传递任意类型的数据，而不仅仅是 React 已知的可渲染类型。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 调用子元素回调 numTimes 次，来重复生成组件
</span><span class='line'>function Repeat(props) {
</span><span class='line'>  let items = [];
</span><span class='line'>  for (let i = 0; i &lt; props.numTimes; i++) {
</span><span class='line'>    items.push(props.children(i));
</span><span class='line'>  }
</span><span class='line'>  return &lt;div&gt;{items}&lt;/div&gt;;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>function ListOfTenThings() {
</span><span class='line'>  return (
</span><span class='line'>    &lt;Repeat numTimes={10}&gt;
</span><span class='line'>    // 回调函数作为children传递
</span><span class='line'>      {(index) =&gt; &lt;div key={index}&gt;This is item {index} in the list&lt;/div&gt;}
</span><span class='line'>    &lt;/Repeat&gt;
</span><span class='line'>  );
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>布尔类型、Null 以及 Undefined 将会忽略</h4>

<p>false, null, undefined, and true 是合法的子元素。但它们并不会被渲染。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;div /&gt;
</span><span class='line'>
</span><span class='line'>&lt;div&gt;&lt;/div&gt;
</span><span class='line'>
</span><span class='line'>&lt;div&gt;{false}&lt;/div&gt;
</span><span class='line'>
</span><span class='line'>&lt;div&gt;{null}&lt;/div&gt;
</span><span class='line'>
</span><span class='line'>&lt;div&gt;{undefined}&lt;/div&gt;
</span><span class='line'>
</span><span class='line'>&lt;div&gt;{true}&lt;/div&gt;</span></code></pre></td></tr></table></div></figure>


<p><strong>值得注意的是有一些 “falsy” 值，如数字 0，仍然会被 React 渲染。</strong>例如，以下代码并不会像你预期那样工作，因为当 props.messages 是空数组时，<em>0 仍然会被渲染</em>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;div&gt;
</span><span class='line'>  {props.messages.length &&
</span><span class='line'>    &lt;MessageList messages={props.messages} /&gt;
</span><span class='line'>  }
</span><span class='line'>&lt;/div&gt;
</span><span class='line'>// 当messages是空数组，会在页面渲染出一个0</span></code></pre></td></tr></table></div></figure>


<p>要解决这个问题，确保 &amp;&amp; 之前的表达式总是布尔值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;div&gt;
</span><span class='line'>  {props.messages.length &gt; 0 &&
</span><span class='line'>    &lt;MessageList messages={props.messages} /&gt;
</span><span class='line'>  }
</span><span class='line'>&lt;/div&gt;</span></code></pre></td></tr></table></div></figure>


<p>反之，如果你想渲染 false、true、null、undefined 等值，你需要先将它们转换为字符串：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;div&gt;
</span><span class='line'>  My JavaScript variable is {String(myVariable)}.
</span><span class='line'>&lt;/div&gt;</span></code></pre></td></tr></table></div></figure>


<h3>shouldComponentUpdate</h3>

<h4>shouldComponentUpdate 的作用</h4>

<p><img src="https://react.docschina.org/static/5ee1bdf4779af06072a17b7a0654f6db/cd039/should-component-update.png" alt="alt text" /></p>

<p>节点 C2 的 shouldComponentUpdate 返回了 false，React 因而不会去渲染 C2，也因此 C4 和 C5 的 shouldComponentUpdate 不会被调用到。</p>

<p>对于 C1 和 C3，shouldComponentUpdate 返回了 true，所以 React 需要继续向下查询子节点。这里 C6 的 shouldComponentUpdate 返回了 true，同时由于渲染的元素与之前的不同使得 React 更新了该 DOM。</p>

<p>最后一个有趣的例子是 C8。React 需要渲染这个组件，但是由于其返回的 React 元素和之前渲染的相同，所以不需要更新 DOM。</p>

<p>显而易见，你看到 React 只改变了 C6 的 DOM。对于 C8，通过对比了渲染的 React 元素跳过了渲染。而对于 C2 的子节点和 C7，由于 shouldComponentUpdate 使得 render 并没有被调用。因此它们也不需要对比元素了。</p>

<h4>Example</h4>

<p>如果你的组件只有当 props.color 或者 state.count 的值改变才需要更新时，你可以使用 shouldComponentUpdate 来进行检查：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CounterButton extends React.Component {
</span><span class='line'>  constructor(props) {
</span><span class='line'>    super(props);
</span><span class='line'>    this.state = {count: 1};
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  shouldComponentUpdate(nextProps, nextState) {
</span><span class='line'>    if (this.props.color !== nextProps.color) {
</span><span class='line'>      return true;
</span><span class='line'>    }
</span><span class='line'>    if (this.state.count !== nextState.count) {
</span><span class='line'>      return true;
</span><span class='line'>    }
</span><span class='line'>    return false;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  render() {
</span><span class='line'>    return (
</span><span class='line'>      &lt;button
</span><span class='line'>        color={this.props.color}
</span><span class='line'>        onClick={() =&gt; this.setState(state =&gt; ({count: state.count + 1}))}&gt;
</span><span class='line'>        Count: {this.state.count}
</span><span class='line'>      &lt;/button&gt;
</span><span class='line'>    );
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你只要继承 <strong>React.PureComponent</strong>就行了。所以这段代码可以改成以下这种更简洁的形式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CounterButton extends React.PureComponent {
</span><span class='line'>  constructor(props) {
</span><span class='line'>    super(props);
</span><span class='line'>    this.state = {count: 1};
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  render() {
</span><span class='line'>    return (
</span><span class='line'>      &lt;button
</span><span class='line'>        color={this.props.color}
</span><span class='line'>        onClick={() =&gt; this.setState(state =&gt; ({count: state.count + 1}))}&gt;
</span><span class='line'>        Count: {this.state.count}
</span><span class='line'>      &lt;/button&gt;
</span><span class='line'>    );
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>大部分情况下，你可以使用 React.PureComponent 来代替手写 shouldComponentUpdate。但它只进行<strong>浅比较</strong>，所以当 props 或者 state 某种程度是可变的话，浅比较会有遗漏，那你就不能使用它了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class ListOfWords extends React.PureComponent {
</span><span class='line'>  render() {
</span><span class='line'>    return &lt;div&gt;{this.props.words.join(',')}&lt;/div&gt;;
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class WordAdder extends React.Component {
</span><span class='line'>  constructor(props) {
</span><span class='line'>    super(props);
</span><span class='line'>    this.state = {
</span><span class='line'>      words: ['marklar']
</span><span class='line'>    };
</span><span class='line'>    this.handleClick = this.handleClick.bind(this);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  handleClick() {
</span><span class='line'>    // 这部分代码很糟，而且还有 bug
</span><span class='line'>    const words = this.state.words;
</span><span class='line'>    words.push('marklar');
</span><span class='line'>    this.setState({words: words});
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  render() {
</span><span class='line'>    return (
</span><span class='line'>      &lt;div&gt;
</span><span class='line'>        &lt;button onClick={this.handleClick} /&gt;
</span><span class='line'>        &lt;ListOfWords words={this.state.words} /&gt;
</span><span class='line'>      &lt;/div&gt;
</span><span class='line'>    );
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>问题在于 PureComponent 仅仅会对新老 this.props.words 的值进行简单的对比。由于代码中 WordAdder 的 handleClick 方法改变了同一个 words 数组，使得新老 this.props.words 比较的其实还是同一个数组。即便实际上数组中的单词已经变了，但是比较结果是相同的。可以看到，即便多了新的单词需要被渲染， ListOfWords 却并没有被更新。</p>

<h4>不可变数据的力量</h4>

<p>避免该问题最简单的方式是避免更改你正用于 props 或 state 的值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>handleClick() {
</span><span class='line'>  this.setState(state =&gt; ({
</span><span class='line'>    words: state.words.concat(['marklar'])
</span><span class='line'>  }));
</span><span class='line'>}
</span><span class='line'>// 或者使用ES6的扩展运算
</span><span class='line'>handleClick() {
</span><span class='line'>  this.setState(state =&gt; ({
</span><span class='line'>    words: [...state.words, 'marklar'],
</span><span class='line'>  }));
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LinkMap]]></title>
    <link href="http://zhoumo199163.github.io/blog/2018/05/19/linkmap/"/>
    <updated>2018-05-19T23:13:19+08:00</updated>
    <id>http://zhoumo199163.github.io/blog/2018/05/19/linkmap</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>  苹果对于提交审核的App中可执行文件有明确的大小限制，查看应用的可执行文件大小就需要利用LinkMap文件。
   <img src="http://zhoumo199163.github.io/images/limitSize.jpg"></p>

<h3>1.如何生成LinkMap文件</h3>

<h4>1).在工程的Build Setting中找到Write Link Map File并打开开关</h4>

<p><img src="http://zhoumo199163.github.io/images/openLinkMap.jpg"></p>

<h4>2).在debug或者release下编译工程</h4>

<h4>3).先找到编译后的app文件，向上两级的Products同目录下有Intermediates.noindex文件夹，在该文件夹下能够找到名称为项目名-LinkMap-normal-x86_64.txt的文件(x86_64是架构，如果是真机，可能为arm64或者其他)</h4>

<p><img src="http://zhoumo199163.github.io/images/linkMapPath.jpg"></p>

<h3>2.LinkMap有什么作用</h3>

<p>LinKMap文件分为四个部分：</p>

<h4>1：# Path:当前LinkMap编译的路径</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Path: /Users/zhoumo1/Library/Developer/Xcode/DerivedData/LinkMapTest-brvtnqhfmtphzohebrymhqgdzhwp/Build/Products/Debug-iphonesimulator/LinkMapTest.app/LinkMapTest</span></code></pre></td></tr></table></div></figure>


<h4>2：# Arch:当前编译的系统架构</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Arch: x86_64</span></code></pre></td></tr></table></div></figure>


<h4>3：# Object files:编译的所有文件</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Object files:
</span><span class='line'>[  0] linker synthesized
</span><span class='line'>[  1] /Users/zhoumo1/Library/Developer/Xcode/DerivedData/LinkMapTest-brvtnqhfmtphzohebrymhqgdzhwp/Build/Intermediates.noindex/LinkMapTest.build/Debug-iphonesimulator/LinkMapTest.build/LinkMapTest.app.xcent
</span><span class='line'>[  2] /Users/zhoumo1/Library/Developer/Xcode/DerivedData/LinkMapTest-brvtnqhfmtphzohebrymhqgdzhwp/Build/Intermediates.noindex/LinkMapTest.build/Debug-iphonesimulator/LinkMapTest.build/Objects-normal/x86_64/ViewController.o
</span><span class='line'>[  3] /Users/zhoumo1/Library/Developer/Xcode/DerivedData/LinkMapTest-brvtnqhfmtphzohebrymhqgdzhwp/Build/Intermediates.noindex/LinkMapTest.build/Debug-iphonesimulator/LinkMapTest.build/Objects-normal/x86_64/main.o
</span><span class='line'>[  4] /Users/zhoumo1/Library/Developer/Xcode/DerivedData/LinkMapTest-brvtnqhfmtphzohebrymhqgdzhwp/Build/Intermediates.noindex/LinkMapTest.build/Debug-iphonesimulator/LinkMapTest.build/Objects-normal/x86_64/AppDelegate.o
</span><span class='line'>[  5] /Users/zhoumo1/Downloads/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk/System/Library/Frameworks//Foundation.framework/Foundation.tbd
</span><span class='line'>[  6] /Users/zhoumo1/Downloads/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk/usr/lib/libobjc.tbd
</span><span class='line'>[  7] /Users/zhoumo1/Downloads/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator11.2.sdk/System/Library/Frameworks//UIKit.framework/UIKit.tbd</span></code></pre></td></tr></table></div></figure>


<h4>4：# Sections:</h4>

<p>段表标题中列举出了地址，大小，段类型以及段名称。<br/>
数据类型分为两种不同类型，一种是<strong>TEXT，用于保存程序代码段经过编译后的机器码，另外一种是</strong>DATA用于保存诸如全局变量或者局部变量。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Sections:
</span><span class='line'># Address Size        Segment Section
</span><span class='line'>0x100001590   0x00000453  __TEXT  __text
</span><span class='line'>0x1000019E4   0x00000036  __TEXT  __stubs
</span><span class='line'>0x100001A1C   0x0000006A  __TEXT  __stub_helper
</span><span class='line'>0x100001A86   0x00000A70  __TEXT  __objc_methname
</span><span class='line'>0x1000024F6   0x0000003C  __TEXT  __objc_classname
</span><span class='line'>0x100002532   0x00000878  __TEXT  __objc_methtype
</span><span class='line'>0x100002DAA   0x0000007A  __TEXT  __cstring
</span><span class='line'>0x100002E24   0x00000186  __TEXT  __entitlements
</span><span class='line'>0x100002FAC   0x00000048  __TEXT  __unwind_info
</span><span class='line'>0x100003000   0x00000010  __DATA  __nl_symbol_ptr
</span><span class='line'>0x100003010   0x00000048  __DATA  __la_symbol_ptr
</span><span class='line'>0x100003058   0x00000010  __DATA  __objc_classlist
</span><span class='line'>0x100003068   0x00000010  __DATA  __objc_protolist
</span><span class='line'>0x100003078   0x00000008  __DATA  __objc_imageinfo
</span><span class='line'>0x100003080   0x00000C48  __DATA  __objc_const
</span><span class='line'>0x100003CC8   0x00000030  __DATA  __objc_selrefs
</span><span class='line'>0x100003CF8   0x00000008  __DATA  __objc_classrefs
</span><span class='line'>0x100003D00   0x00000008  __DATA  __objc_superrefs
</span><span class='line'>0x100003D08   0x00000008  __DATA  __objc_ivar
</span><span class='line'>0x100003D10   0x000000A0  __DATA  __objc_data
</span><span class='line'>0x100003DB0   0x000000C0  __DATA  __data</span></code></pre></td></tr></table></div></figure>


<h4>5：# Symbols:文件中每一个方法的大小</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Symbols:
</span><span class='line'># Address Size        File  Name
</span><span class='line'>0x100001590   0x00000040  [  2] -[ViewController viewDidLoad]
</span><span class='line'>0x1000015D0   0x00000050  [  2] -[ViewController viewDidAppear:]
</span><span class='line'>0x100001620   0x00000050  [  2] -[ViewController viewWillAppear:]
</span><span class='line'>0x100001670   0x00000050  [  2] -[ViewController viewDidDisappear:]
</span><span class='line'>0x1000016C0   0x0000003C  [  2] -[ViewController didReceiveMemoryWarning]
</span><span class='line'>0x100001700   0x00000090  [  3] _main
</span><span class='line'>0x100001790   0x00000080  [  4] -[AppDelegate application:didFinishLaunchingWithOptions:]
</span><span class='line'>0x100001810   0x00000040  [  4] -[AppDelegate applicationWillResignActive:]
</span><span class='line'>0x100001850   0x00000040  [  4] -[AppDelegate applicationDidEnterBackground:]
</span><span class='line'>0x100001890   0x00000040  [  4] -[AppDelegate applicationWillEnterForeground:]
</span><span class='line'>0x1000018D0   0x00000040  [  4] -[AppDelegate applicationDidBecomeActive:]
</span><span class='line'>0x100001910   0x00000040  [  4] -[AppDelegate applicationWillTerminate:]
</span><span class='line'>0x100001950   0x00000020  [  4] -[AppDelegate window]
</span><span class='line'>0x100001970   0x00000040  [  4] -[AppDelegate setWindow:]
</span><span class='line'>0x1000019B0   0x00000033  [  4] -[AppDelegate .cxx_destruct]
</span><span class='line'>···</span></code></pre></td></tr></table></div></figure>


<h3>3.如何减少库大小</h3>

<p>除了第三方的库以外，我们还能对自己的代码做些什么？</p>

<h4>1）注释或删除空方法和没有调用的方法</h4>

<p>如上文分析，类中存在的方法就会被计算大小，无论是否调用。所以可以删除类中 如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewWillAppear:(BOOL)animated{
</span><span class='line'>    [super viewWillAppear:animated];
</span><span class='line'>}
</span><span class='line'>- (void)viewDidDisappear:(BOOL)animated{
</span><span class='line'>    [super viewDidDisappear:animated];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>多加了两个空方法的大小对比如下,虽然空方法占用的很少，但是如果数量比较多还是很可观。
<img src="http://zhoumo199163.github.io/images/compare1.jpg"></p>

<h4>2）比较去重</h4>

<p>分析过滤项目中的重复代码。通过整合减少代码量。</p>

<p>介绍一种去重的方法，使用PMD去重：<br/>
1.下载：<a href="https://sourceforge.net/projects/pmd/files/pmd/">https://sourceforge.net/projects/pmd/files/pmd/</a><br/>
2.cd 到bin目录中<br/>
3.在终端输入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./run.sh cpd --language ObjectiveC --minimum-tokens 100 --files /Users/zhoumo1/Desktop/LinkMap/LinkMapTest/LinkMapTest &gt; /Users/zhoumo1/Desktop/check.txt </span></code></pre></td></tr></table></div></figure>


<p>4.查看结果~完美</p>

<h4>3）升级最低版本||重构</h4>

<p>这没什么好说的，iOS9已经支持到500M，如果实在不能删减，升级最低支持版本是最有效的。</p>

<p>重构风险较大，并且重构后也不一定会小很多，不支持。</p>

<h3>4.LinkMap比对</h3>

<p>为了方便查看做了以上减少工作后的结果如何，于是写了一个简单的Mac应用，主要功能是对比两份LinkMap文件。</p>

<p>git地址：<a href="https://github.com/zhoumo199163/compareLinkMap">https://github.com/zhoumo199163/compareLinkMap</a></p>

<p>如果觉得对你有用，欢迎star~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[算法和数据结构]]></title>
    <link href="http://zhoumo199163.github.io/blog/2017/12/31/suan-fa-he-shu-ju-jie-gou/"/>
    <updated>2017-12-31T21:59:25+08:00</updated>
    <id>http://zhoumo199163.github.io/blog/2017/12/31/suan-fa-he-shu-ju-jie-gou</id>
    <content type="html"><![CDATA[<h3>1.找到字符串中最长无重复子串</h3>

<ul>
<li>例如aabbc，最长无重复子串abc，长度3；abcd，长度4；</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 思路：
</span><span class='line'>// 1.先申请一个字典，key是每一个字符，value是字符上一次出现的位置
</span><span class='line'>// 2.pre：该字符上次出现的位置
</span><span class='line'>// 3.cur:当前位置和上次出现位置的距离
</span><span class='line'>// 4.len:最长距离
</span><span class='line'>- (void)maxUniqu:(NSString *)string{
</span><span class='line'>    NSMutableDictionary *nums = [NSMutableDictionary new];
</span><span class='line'>    NSArray  *array = [string componentsSeparatedByString:@","];
</span><span class='line'>    [array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
</span><span class='line'>        nums[obj] = @(-1);
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>   __block int pre = -1;
</span><span class='line'>   __block int len = 0;
</span><span class='line'>   __block int cur = 0;
</span><span class='line'>    [array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
</span><span class='line'>        pre = MAX(pre, [nums[obj] intValue]);
</span><span class='line'>        cur = idx - pre;
</span><span class='line'>        len = MAX(len, cur);
</span><span class='line'>        nums[obj] = @(idx);
</span><span class='line'>        NSLog(@"\nobj:%@\npre:%d\ncur:%d\nlen:%d\nnums:%@",obj,pre,cur,len,nums);
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS_Q&amp;A]]></title>
    <link href="http://zhoumo199163.github.io/blog/2017/12/24/ios-q-and-a/"/>
    <updated>2017-12-24T14:46:28+08:00</updated>
    <id>http://zhoumo199163.github.io/blog/2017/12/24/ios-q-and-a</id>
    <content type="html"><![CDATA[<h3>Q1.通知是同步还是异步？</h3>

<ul>
<li>A1:通知是同步的。测试如下：</li>
</ul>


<pre><code class="`"> [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(print:) name:@"GCDNotification" object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(print1:) name:@"GCDNotification" object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(print2:) name:@"GCDNotification" object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(print3:) name:@"GCDNotification" object:nil];

    [[NSNotificationCenter defaultCenter] postNotificationName:@"GCDNotification" object:nil];
        NSLog(@"发出通知----%@",[NSThread currentThread]);

    - (void)print:(NSNotification *)notif{
        NSLog(@"0收到通知----%@",[NSThread currentThread]);

        sleep(10);
}
// log 
2017-12-24 15:07:58.552422+0800 KVOTest[7306:368524] 0收到通知----&lt;NSThread: 0x604000066840&gt;{number = 1, name = main}
2017-12-24 15:08:08.553940+0800 KVOTest[7306:368524] 1收到通知----&lt;NSThread: 0x604000066840&gt;{number = 1, name = main}
2017-12-24 15:08:18.555010+0800 KVOTest[7306:368524] 2收到通知----&lt;NSThread: 0x604000066840&gt;{number = 1, name = main}
2017-12-24 15:08:28.557206+0800 KVOTest[7306:368524] 3收到通知----&lt;NSThread: 0x604000066840&gt;{number = 1, name = main}
2017-12-24 15:08:38.559301+0800 KVOTest[7306:368524] 发出通知----&lt;NSThread: 0x604000066840&gt;{number = 1, name = main}
</code></pre>

<ul>
<li>模拟实现异步接收的效果如下：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> -(void)print:(NSNotification *)notif{
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        NSLog(@"0收到通知----%@",[NSThread currentThread]);
</span><span class='line'>        sleep(10);
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>// log
</span><span class='line'>2017-12-24 15:11:09.680454+0800 KVOTest[7325:373178] 2收到通知----&lt;NSThread: 0x60000026c880&gt;{number = 5, name = (null)}
</span><span class='line'>2017-12-24 15:11:09.680454+0800 KVOTest[7325:373056] 3收到通知----&lt;NSThread: 0x60400006e800&gt;{number = 1, name = main}
</span><span class='line'>2017-12-24 15:11:09.680488+0800 KVOTest[7325:373176] 0收到通知----&lt;NSThread: 0x60000026c040&gt;{number = 3, name = (null)}
</span><span class='line'>2017-12-24 15:11:09.680491+0800 KVOTest[7325:373175] 1收到通知----&lt;NSThread: 0x60400027d440&gt;{number = 4, name = (null)}
</span><span class='line'>2017-12-24 15:11:19.682627+0800 KVOTest[7325:373056] 发出通知----&lt;NSThread: 0x60400006e800&gt;{number = 1, name = main}</span></code></pre></td></tr></table></div></figure>


<h3>Q2.UIView和CALayer的父类及关系？</h3>

<ul>
<li>UIView的父类是UIResponse，可以响应事件和手势</li>
<li>CALyer的父类是NSObject，不可以响应事件和手势，更偏重内容绘制</li>
<li>每个UIView都有自己的CALayer，UIView的frame只是返回CALayer的frame</li>
<li>在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate</li>
</ul>


<h3>Q3.手动设置UIView的bounds会怎样？</h3>

<ul>
<li>[UIview setBounds:]改变当前view相对于子view的坐标原点。</li>
</ul>


<pre><code class="`"> UIView *view1 = [[UIView alloc] initWithFrame:CGRectMake(0,0, 375, 100)];
    [view1 setBackgroundColor:[UIColor grayColor]];
    [self.view addSubview:view1];

    // 改变后，view1的原点在（0，-100）位置
    self.view.bounds = CGRectMake(0, -100, CGRectGetWidth(self.view.frame), CGRectGetHeight(self.view.frame));
</code></pre>

<p> <img src="http://zhoumo199163.github.io/images/noSetBounds.png">
 <img src="http://zhoumo199163.github.io/images/setBounds.png"></p>

<h3>Q4.在xib中创建一个全view大小的tableview，会不会被导航栏遮挡？为什么？</h3>

<ul>
<li>正常情况下，导航栏的透明度可影响视图是否被遮挡</li>
</ul>


<pre><code class="`"> // 设置不透明，self.view在导航栏下面展示，不遮挡
 // 否则，self.view为全屏展示，会被导航栏遮挡
 self.navigationController.navigationBar.translucent = NO;
</code></pre>

<ul>
<li>在不考虑以上透明度的影响，tableview不被遮挡的同时还需要滑动时在不透明的导航栏中透出</li>
</ul>


<pre><code class="`">  // iOS10 以上系统自动设置，以下需要手动设置
  [self.tableView setContentInset:UIEdgeInsetsMake(64, 0, 0, 0)];
</code></pre>

<h3>Q5.动态库和静态库的区别？系统库属于哪种？</h3>

<ul>
<li>静态库以.a和.framework作为文件后缀名，在使用时会被完全的copy一份到文件中，多次使用就包含多次拷贝文件，平时使用的第三方库大部分都是静态库，会使app的体积变大。</li>
<li>动态库以.framework和.tbd(之前叫.dylib)作为文件后缀名，在使用时不会拷贝，由系统动态加载到内存中，只加载一次，多次使用可节省空间。如系统库UIKit等都是动态库。</li>
<li>动态库制作可以包含其他静态库(.a/.framework)</li>
<li>静态库制作可以包含其他静态库(.a/.framework）</li>
</ul>


<h3>Q6.为什么加载xib文件比纯代码耗时？</h3>

<ul>
<li>xib实质是xml文件，系统先要解析xml文件中的view及参数属性。</li>
</ul>


<h3>Q7.podfile.lock的作用？</h3>

<ul>
<li>在使用命令【pod install】以后会生成podfile.lock文件，这个文件中保存已经安装的Pods依赖库的版本。</li>
<li>在多人协作时，特别是在podfile文件中没有指定依赖版本号时，如果有podfile.lock文件，其他人在执行【pod install】时就会和最开始的用户保持版本一致。如果没有podfile.lock文件，可能更新出不同的版本。所以podfile.lock需要加入版本管理。</li>
</ul>


<pre><code class="`"> // podfile 
 platform :ios, '9.0'
def shared_pods
    pod 'FMDB' // 不指定版本，获取最新版本
end
target 'LittleNotes' do 
    shared_pods
end
target 'LittleNotesWidget' do
    shared_pods
end
</code></pre>

<pre><code class="`"> //podfile.lock
 PODS:
  - FMDB (2.7.2):
    - FMDB/standard (= 2.7.2)
  - FMDB/standard (2.7.2)
DEPENDENCIES:
  - FMDB
SPEC CHECKSUMS:
  FMDB: 6198a90e7b6900cfc046e6bc0ef6ebb7be9236aa
PODFILE CHECKSUM: f5e7b7c51ca371b02aa28c158108e5f9ccdf3033
COCOAPODS: 1.3.1
</code></pre>

<h3>Q8.如何优化应用启动时间？</h3>

<ul>
<li>冷启动：启动的应用不在后台运行，系统需要重新创建一个新进程分配给应用。App启动时间是从手指点击到调用applicationWillFinishLaunching结束</li>
<li>热启动：应用已经运行，但是被后台挂起，比如按了home键。App的启动时间是从手指点击到调用applicationWillEnterForeground。</li>
<li>测量应用启动时间：Xcode - Edit scheme - Auguments 配置环境变量DYLD_PRINT_STATISTICS为1.</li>
</ul>


<pre><code class="`"> Total pre-main time:  99.69 milliseconds (100.0%)
         dylib loading time:  39.31 milliseconds (39.4%)
        rebase/binding time:   7.57 milliseconds (7.5%)
            ObjC setup time:  10.25 milliseconds (10.2%)
           initializer time:  42.39 milliseconds (42.5%)
           slowest intializers :
             libSystem.B.dylib :  11.93 milliseconds (11.9%)
   libBacktraceRecording.dylib :   7.14 milliseconds (7.1%)
    libMainThreadChecker.dylib :  17.24 milliseconds (17.2%)
</code></pre>

<p> 影响启动时间因素：
 - 动态库加载时间。一般应用会加载 100 到 400 个 dylib 文件，但大部分都是系统 dylib，它们会被预先计算和缓存起来，加载速度很快。但是另外集成的动态库应该尽量减少动态库的数量，或者将多个动态库合成一个。尽量保证将App现有的非系统级的动态库个数保证在6个以内。
 - 指针修正时间。减少指针数量。就是减少App中的类、category、selector的数量。
 - 初始化时间：使用+initialize代替+load方法，不要使用<strong>attribute</strong>((constructor)) 将方法显式标记为初始化器</p>

<pre><code class="``">  load -&gt; attribute((constructor)) -&gt; main -&gt; initialize
  + (void)initialize{
    // 在类被第一次使用的时候调用
  }
  + (void)load{
    // 在类被运行时加载时调用
  }
  __attribute((constructor)) void beforeMain(){
  //是GCC的扩展语法（黑魔法），由它修饰过的函数，会在main函数之前调用
  }
</code></pre>

<h3>Q9.dSYM是什么文件，有什么作用？</h3>

<ul>
<li>每次编译build/Archive App时，会生成一个同名的dSYM文件，dSYM 是保存 16 进制函数地址映射信息的中转文件.</li>
<li>.dSYM中真正保存符号表数据的是DWARF文件。DWARF（DebuggingWith Arbitrary Record Formats），是ELF和Mach-O等文件格式中用来存储和处理调试信息的标准格式。</li>
<li><p>.dSYM文件主要用于在发生崩溃时，根据崩溃内存地址查找到具体的崩溃位置。</p></li>
<li><p>1.首先必须保.dSYM和.app文件是对应的</p></li>
</ul>


<pre><code class="`"> // 通过读取文件中的UUID
 dwarfdump --uuid xx.app/xx (xx代表你的项目名)
 dwarfdump --uuid xx.app.dSYM;
</code></pre>

<ul>
<li>2.崩溃错误信息</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> // 一般崩溃信息格式
</span><span class='line'>appName 0x000000010011496c appName + 379244
</span><span class='line'>
</span><span class='line'> // 0x000000010011496c:崩溃内存地址，十六进制
</span><span class='line'> 379244：地址偏移量，十进制</span></code></pre></td></tr></table></div></figure>


<ul>
<li>3.定位</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> // 终端运行
</span><span class='line'> atos -arch arm64（1） -o "dSYM文件路径（2）" -l 0x00000001000B8000（3） 0x000000010011496c
</span><span class='line'> 
</span><span class='line'> // 1.处理器指令集，真机64位处理器为arm64，32位处理器为armv7或armv7s
</span><span class='line'> // 2.将dSYM文件-右键-显示包内容，定位到DWARF目录下的app同名文件，如：/Users/zm/Desktop/ywh_dSYM/2.1.1/uclture.app.dSYM/Contents/Resources/DWARF/玩事
</span><span class='line'> // 3.初始内存地址：将十六进制崩溃内存地址转化为十进制后，减去地址偏移量，获得十进制内存初始地址，再转化成十六进制
</span><span class='line'> 如：0x000000010011496c（16）= 4296100204（10）
</span><span class='line'> 初始地址（10） = 4296100204 - 379244 = 4295720960
</span><span class='line'> 4295720960（10） = 1000B8000（16）
</span><span class='line'> 
</span><span class='line'> // 运行结果
</span><span class='line'> -[HonorChatViewController tableView:heightForRowAtIndexPath:] (in ) (HonorChatViewController.m:193)</span></code></pre></td></tr></table></div></figure>


<h3>Q9.关于设置frame和autolayout布局的区别</h3>

<ul>
<li>手动设置frame，虽然也可以设置相对位置，不过需要大量的计算。</li>
<li>设置autolayout不需要自己去计算</li>
<li>直接设置frame在屏幕旋转等事件发生时需要重新适配计算位置，autolayout不需要</li>
</ul>


<h3>Q10.怎么避免NSTimer的循环引用？</h3>

<ul>
<li>1.不重复timer</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  _timer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(todoSomething) userInfo:nil repeats:NO];
</span><span class='line'>  // timer在执行一次selector后自动调用invalidate方法，不会造成循环应用</span></code></pre></td></tr></table></div></figure>


<ul>
<li>2.重复执行的timer</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> _timer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(todoSomething) userInfo:nil repeats:YES];
</span><span class='line'> // 重复的timer必须手动执行invalidate方法，且不能再dealloc中执行，因为timer强引用self，导致self不能释放，不会触发dealloc</span></code></pre></td></tr></table></div></figure>


<ul>
<li><ol>
<li>invalidate方法的作用</li>
</ol>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Stops the timer from ever firing again and requests its removal from its run loop.
</span><span class='line'>This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes its strong reference to the timer, either just before the invalidate method returns or at some later point.
</span><span class='line'>If it was configured with target and user info objects, the receiver removes its strong references to those objects as well.
</span><span class='line'>停止计时器再次触发，并请求将其从运行循环中删除。
</span><span class='line'>该方法是从NSRunLoop对象中删除计时器的惟一方法。NSRunLoop对象删除了它对计时器的强引用，或者是在无效的方法返回之前，或者在稍后的某个时间点。
</span><span class='line'>如果它配置了目标和用户信息对象，接收者也会删除对这些对象的强引用。</span></code></pre></td></tr></table></div></figure>


<h3>Q11.在block中使用_xxx的方式使用属性会不会循环引用？</h3>

<ul>
<li>会产生循环引用</li>
<li>_name和self.name的区别是self.name直接调用属性的get方法，</li>
<li>_name是调用类的实例变量。都会传入self被block强引用。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.block = ^(id target) {
</span><span class='line'>        _name = @"weekend";
</span><span class='line'>    };
</span><span class='line'>    self.block(self);</span></code></pre></td></tr></table></div></figure>


<h3>Q12.设计一个方法查询指定view上所有相同类型的子控件</h3>

<ul>
<li>1.需要想到view的子view的子view&hellip;中也要查找</li>
<li>2.自定义继承的控件也需要查找</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1.使用递归查找子view
</span><span class='line'>// 2.自定义控件使用isKindOfClass
</span><span class='line'>- (NSInteger)searchSubviewsCountByType:(NSString *)type atView:(UIView *)view{
</span><span class='line'>   __block NSInteger count = 0;
</span><span class='line'>    NSArray &lt;UIView*&gt; *subviews = view.subviews;
</span><span class='line'>    [subviews enumerateObjectsUsingBlock:^(UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
</span><span class='line'>        NSInteger subCount = 0;
</span><span class='line'>        if(obj.subviews.count != 0){
</span><span class='line'>            subCount = subCount + [self searchSubviewsCountByType:type atView:obj];
</span><span class='line'>        }else{
</span><span class='line'>            Class targetClass = NSClassFromString(type);
</span><span class='line'>            if([obj isKindOfClass:targetClass]){
</span><span class='line'>                subCount++;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        count = count + subCount;
</span><span class='line'>    }];
</span><span class='line'>    return count;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// isKindOfClass:返回一个布尔值，该值表示接收者是给定类的实例还是继承该类的任何类的实例。
</span><span class='line'>Returns a Boolean value that indicates whether the receiver is an instance of given class or an instance of any class that inherits from that class.
</span><span class='line'>// isMemberOfClass:返回一个布尔值，该值表示接收者是否为给定类的实例。
</span><span class='line'>Returns a Boolean value that indicates whether the receiver is an instance of a given class.</span></code></pre></td></tr></table></div></figure>


<h3>Q13.在主线程中新建一个串行队列，同步执行任务，任务在哪个线程中执行？为什么？</h3>

<ul>
<li>任务执行在主线程</li>
<li>串行队列：队列中的任务按照顺序执行</li>
<li>并行队列：队列中的任务同时执行</li>
<li>同步：阻塞当前线程，直到任务执行完毕</li>
<li>异步：不阻塞当前线程</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 同步串行：阻塞当前主线程，并顺序执行。不同的任务队列不会发生死锁。
</span><span class='line'> dispatch_sync(dispatch_queue_create("serial", DISPATCH_QUEUE_SERIAL), ^{
</span><span class='line'>        NSLog(@"currentThread:%@",[NSThread currentThread]);
</span><span class='line'>    });
</span><span class='line'>//log:
</span><span class='line'>currentThread:&lt;NSThread: 0x604000076c40&gt;{number = 1, name = main}
</span><span class='line'>
</span><span class='line'>// 死锁：当前队列等待block中的任务执行完毕，block中任务阻塞主线程等待主线程队列中的任务执行完毕。
</span><span class='line'>dispatch_sync(dispatch_get_main_queue(), ^{
</span><span class='line'>        NSLog(@"currentThread:%@",[NSThread currentThread]);
</span><span class='line'>    });</span></code></pre></td></tr></table></div></figure>


<h3>Q14.在dealloc中写以下方法会输出什么？</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)dealloc{
</span><span class='line'>    __weak typeof(self) weakSelf = self;
</span><span class='line'>    NSLog(@"weakSelf:%@",weakSelf);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>运行崩溃：objc[1653]: Cannot form weak reference to instance (0x7fc3a8c0c920) of class TestViewController. It is possible that this object was over-released, or is in the process of deallocation.</li>
<li>dealloc:释放被接收方占用的内存。
接收到接收方的后续消息可能会产生一个错误，指示消息被发送到一个回收对象(前提是该回收的内存还没有被重用)。</li>
<li>当前self在回收过程中，不允许弱引用</li>
</ul>


<h3>Q15.怎么在当前页面关闭的时候取消还没有下载完成的任务？</h3>

<ul>
<li>1.NSOperation</li>
</ul>


<pre><code class="`"> // 1.添加任务到队列
  self.operationQueue = [NSOperationQueue new];
    self.operationQueue.maxConcurrentOperationCount = 1;
    for(int i = 0;i&lt;10;i++){
        [self.operationQueue addOperationWithBlock:^{
            sleep(1);
            NSLog(@"i == %d",i);
        }];
    }
  // 2. 挂起队列，不能暂停正在执行的任务
   [self.operationQueue setSuspended:YES];
  // 3. 取消挂起
  [self.operationQueue setSuspended:No];
  // 4.取消全部任务
    [self.operationQueue cancelAllOperations];
   // 5.取消单个任务
    NSBlockOperation *blockOp = [NSBlockOperation blockOperationWithBlock:^{
        // do something
    }];
    [self.operationQueue addOperation:blockOp];
    [blockOp cancel];
</code></pre>

<ul>
<li>2.GCD</li>
</ul>


<pre><code class="`"> // 1.添加任务到队列
  dispatch_block_t gcdBlcok = dispatch_block_create(0, ^{
        NSLog(@"to do something");
    });
    dispatch_async(self.queue, gcdBlcok);
  // 2.取消任务
  dispatch_block_cancel(gcdBlcok);
  OR dispatch_cancel(gcdBlcok);
  // 3.挂起队列
  dispatch_suspend(self.queue);
  // 4.取消挂起
  dispatch_resume(self.queue);
</code></pre>

<ul>
<li>3.页面关闭时，取消队列中还没有开始的任务。如果使用GCD需要将任务单独生成一个dispatch_block_t对象，如果是NSOperation，直接调用
cancelAllOperations。</li>
</ul>

]]></content>
  </entry>
  
</feed>
